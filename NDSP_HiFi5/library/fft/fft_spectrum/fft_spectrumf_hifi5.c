/* ------------------------------------------------------------------------ */
/* Copyright (c) 2021 by Cadence Design Systems, Inc. ALL RIGHTS RESERVED.  */
/* These coded instructions, statements, and computer programs ('Cadence    */
/* Libraries') are the copyrighted works of Cadence Design Systems Inc.     */
/* Cadence IP is licensed for use with Cadence processor cores only and     */
/* must not be used for any other processors and platforms. Your use of the */
/* Cadence Libraries is subject to the terms of the license agreement you   */
/* have entered into with Cadence Design Systems, or a sublicense granted   */
/* to you by a direct Cadence license.                                     */
/* ------------------------------------------------------------------------ */
/*  IntegrIT, Ltd.   www.integrIT.com, info@integrIT.com                    */
/*                                                                          */
/* NatureDSP_Baseband Library                                               */
/*                                                                          */
/* This library contains copyrighted materials, trade secrets and other     */
/* proprietary information of IntegrIT, Ltd. This software is licensed for  */
/* use with Cadence processor cores only and must not be used for any other */
/* processors and platforms. The license to use these sources was given to  */
/* Cadence, Inc. under Terms and Condition of a Software License Agreement  */
/* between Cadence, Inc. and IntegrIT, Ltd.                                 */
/* ------------------------------------------------------------------------ */
/*          Copyright (C) 2009-2021 IntegrIT, Limited.                      */
/*                      All Rights Reserved.                                */
/* ------------------------------------------------------------------------ */
/*
 * Power spectrum, floating point data
 * Code optimized for HiFi5 core
 */
/* Cross-platform data type definitions. */
#include "NatureDSP_types.h"
/* Common helper macros. */
#include "common.h"
/* Signal Processing Library API. */
#include "NatureDSP_Signal_fft.h"
#include "common_fpu.h"

#if HAVE_VFPU

#define SMALLER_CODESIZE 1 // 1 save code size, 2 - save even more but with some performance loss on bigger N

inline_ void sqrt_sx2x2(xtfloatx2 *pvd0,xtfloatx2 *pvd1,const xtfloatx2 *pvs0,const xtfloatx2 *pvs1) 
{
        xtfloatx2 vs0=pvs0[0],vs1=pvs1[0];
        xtfloatx2 f20,f21,f30,f31,f40,f41,f00,f01,f60,f61,f70,f71,f10,f11; 
        f20=SQRT0_SX2(vs0); f21=SQRT0_SX2(vs1);
        MUL_SX2X2 (f30,f31,f20,f21,f20,f21);
        f40=NEXP01_SX2(vs0); f41=NEXP01_SX2(vs1);
        CONST_SX2X2(f00,f01, 3);
        ADDEXP_SX2(f40, f00); ADDEXP_SX2(f41, f01);
        MADD_SX2X2 (f00,f01, f30,f31,f40,f41);
        f30=NEXP01_SX2(vs0); f31=NEXP01_SX2(vs1);
        MADD_SX2X2 (f20,f21,f00,f01, f20,f21);
        MUL_SX2X2(f00,f01, f30,f31, f20,f21); NEG_SX2X2(f00,f01,f00,f01);
        MUL_SX2X2 (f60,f61, f20,f21, f40,f41);
        CONST_SX2X2(f40,f41, 3);
        MUL_SX2X2  (f70,f71, f40,f41, f20,f21);
        MADD_SX2X2 (f30,f31, f00,f01, f00,f01);
        MADD_SX2X2 (f40,f41, f60,f61, f20,f21);
        NEG_SX2X2 (f70,f71, f70,f71);
        MADD_SX2X2 (f00,f01, f30,f31, f70,f71);
        MSUB_SX2X2 (f70,f71, f40,f41, f70,f71);
        f30=f70; f31=f71;
        f20=MKSADJ_SX2(vs0); f21=MKSADJ_SX2(vs1);
        f10=NEXP01_SX2(vs0); f11=NEXP01_SX2(vs1);
        MADD_SX2X2(f10,f11, f00,f01, f00,f01);
        ADDEXPM_SX2(f00, f20); ADDEXPM_SX2(f01, f21);
        ADDEXP_SX2 (f30, f20); ADDEXP_SX2 (f31, f21);
        DIVN_SX2(f00,f10, f30); DIVN_SX2(f01,f11, f31);
        *pvd0=f00; *pvd1=f01;
}
#define SQRT_SX2X2(vd0,vd1,vs0,vs1) sqrt_sx2x2(&vd0,&vd1,&vs0,&vs1);
#endif

/*-------------------------------------------------------------------------
  Power spectrum
  These functions compute a normalized power spectrum from the output signal 
  generated by an FFT function. The N argument specifies the size of the FFT 
  and must be a power of 2. The  mode argument is used to specify the type 
  of FFT function used to generate the x array. If the x array has been 
  generated from a frequency-domain complex input signal (output of complex 
  FFT function), the mode argument must be set to 0. Otherwise the mode 
  argument must be set to 1 to signify that the x array has been generated 
  from a frequency-domain real input signal (output of real FFT function).
  The block_exponent argument is used to control the normalization of the 
  power spectrum. It will usually be set to the block_exponent that is 
  returned by corresponding FFT functions.  If the input array was 
  generated by some other means, then the value specified for the 
  block_exponent argument will depend upon how the FFT was calculated. 
  If the function used to calculate the FFT did not scale the intermediate 
  results at any of the stages of the computation, then set block_exponent 
  to zero; if the FFT function scaled the intermediate results at each 
  stage of the computation, then set block_exponent to -1; otherwise set 
  block_exponent to the sum of negated base-2 logarithm of all scaling 
  factors applied to data at intermediate FFT stages. This value will be 
  in the range 0 to log2(N).
  fft_spectrum functions write the power spectrum to the output array y. 
  If mode is set to 0, then the length of the power spectrum will be N. If 
  mode is set to 1, then the length of the power spectrum will be (N/2+1)

  Precision:
  16x32   16-bit inputs, 32-bit outputs
  32x32   32-bit inputs/outputs
  f       floating point inputs/outputs. Requires VFPU/SFPU core option


  Input:
  for mode==0
  x[N]           input spectrum . Real and imaginary
                 data are interleaved and real data goes first:
  for mode==1
  x[N/2+1]       input spectrum (positive side). Real and imaginary
                 data are interleaved and real data goes first:
  block_exponent power spectrum normalization control
  N              FFT size
  mode           power spectrum mode:
                 0 – complex signal
                 1 – real signal

  twdstep               twiddle step
  scalingOpt            scaling option (see table above), not applicable 
                        to the floating point function
  Output:
  for mode==0
  y[N]           output power spectrum
  for mode==1
  y[N/2+1]       output power spectrum
  Returned value:  none

  Restrictions:
  x,y   should not overlap
  x,y   aligned on 16-bytes boundary
-------------------------------------------------------------------------*/
#if (HAVE_FPU==0 && HAVE_VFPU==0)
DISCARD_FUN(void,fft_spectrumf,(float32_t* y, const complex_float   * x, int N,int mode ))
#elif (HAVE_VFPU)
void fft_spectrumf     ( float32_t* restrict y, const complex_float   * restrict x, int N,                     int mode )
#if SMALLER_CODESIZE==1
{
    float32_t ALIGN(16) buff[8];
    float32_t *saved_y=NULL;
    int32_t saved_N=0;
    int n, logN;
    xtfloatx2 scale;
    ae_valign aY;
    ae_valignx2 aX;
    static const union {  uint32_t  u;  float32_t f; }
                 xmin={0x20000000}, // sqrt(realmin)
                 xmax={0x5f000000}, // sqrt(realmax)/2
                 k   ={0x6a800000}, // direct and inverse scale factors 
                 kinv={0x14800000}; //
    NASSERT( x );
    NASSERT( y );

    if ( N<2 || 0 != (N&(N-1)) || ( mode != 0 && mode != 1 ) ) return;

    logN = 30 - NSA( N );
    scale = XT_AE_MOVXTFLOATX2_FROMINT32X2(AE_MOVDA32((127+mode-logN)<<23));   /* 2^(mode-logN) */
    N=( mode ? N/2+1 : N );

    do
    {
        aY=AE_ZALIGN64();
        aX=AE_LA128_PP(x);
        for ( n=0; n<(N>>2); n++)
        {
            xtbool2 bsmall,bbig;
            xtfloatx2 reim0,reim1,rere,imim,maxreim,r0,r1,t0,t1;
            xtfloatx2 s,sinv0,sinv1;

            AE_LASX2X2_IP(reim0,reim1,aX,castxcc(xtfloatx4,x));
            ABS_SX2X2(reim0,reim1,reim0,reim1);
            rere=AE_SEL32_HH_SX2(reim0,reim1);
            imim=AE_SEL32_LL_SX2(reim0,reim1);
            maxreim=MAXNUM_SX2(rere,imim);
            bsmall=XT_OLE_SX2(maxreim,xmin.f);
            bbig  =XT_OLE_SX2(xmax.f,maxreim);
            CONST_SX2X2(sinv0,s,1);
            XT_MOVT_SX2(s,k.f,bsmall);
            XT_MOVT_SX2(sinv0,kinv.f,bsmall);
            XT_MOVT_SX2(s,kinv.f,bbig);
            XT_MOVT_SX2(sinv0,k.f,bbig);
            sinv0=XT_MUL_SX2(sinv0,scale);
            MUL_SX2X2(rere,imim,rere,imim,s,s);
            MUL_SX2X2(r0,t0,rere,imim,rere,imim);

            AE_LASX2X2_IP(reim0,reim1,aX,castxcc(xtfloatx4,x));
            ABS_SX2X2(reim0,reim1,reim0,reim1);
            rere=AE_SEL32_HH_SX2(reim0,reim1);
            imim=AE_SEL32_LL_SX2(reim0,reim1);
            maxreim=MAXNUM_SX2(rere,imim);
            bsmall=XT_OLE_SX2(maxreim,xmin.f);
            bbig  =XT_OLE_SX2(xmax.f,maxreim);
            CONST_SX2X2(sinv1,s,1); 
            XT_MOVT_SX2(s,k.f,bsmall);
            XT_MOVT_SX2(sinv1,kinv.f,bsmall);
            XT_MOVT_SX2(s,kinv.f,bbig);
            XT_MOVT_SX2(sinv1,k.f,bbig);
            sinv1=XT_MUL_SX2(sinv1,scale);
            MUL_SX2X2(rere,imim,rere,imim,s,s);
            MUL_SX2X2(r1,t1,rere,imim,rere,imim);

            ADD_SX2X2(r0,r1,r0,r1,t0,t1);
            SQRT_SX2X2(r0,r1,r0,r1);
            MUL_SX2X2(r0,r1,r0,r1,sinv0,sinv1);

            XT_SASX2IP(r0,aY,castxcc(xtfloatx2,y));
            XT_SASX2IP(r1,aY,castxcc(xtfloatx2,y));
        }
        AE_SA64POS_FP(aY,castxcc(xtfloatx2,y));
        N&=3;
        if (N)
        {
            AE_S32X2X2_I(0,0,(ae_int32x4*)buff,0);
            AE_S32X2X2_I(0,0,(ae_int32x4*)buff,1*sizeof(ae_int32x4));
            __Pragma("no_unroll")
            __Pragma("concurrent")
            for (n=0; n<N; n++) ((complex_float*)buff)[n]=x[n];
            saved_N=N;
            saved_y=y;
            x=(complex_float*)buff;
            y=buff;
            N=4;
        }
    }
    while (N>0);

    if (saved_y)
    {
        __Pragma("no_unroll")
        __Pragma("concurrent")
        for (n=0; n<saved_N; n++) saved_y[n]=buff[n];
    }
} 
#elif SMALLER_CODESIZE==2 && defined (AE_LAV16X4X2_XP) && defined (AE_SAV16X4X2_XP)
{
    ae_int16x4 tmp0,tmp1,change1632;
    static const int16_t ALIGN(16) change1632_tbl[]={6|(2<<8), 7|(3<<8), 4|(0<<8), 5|(1<<8)};
    int nbytesWr,nbytesRd;
    int n, logN;
    xtfloatx2 scale;
    ae_valignx2 aY;
    ae_valignx2 aX;
    static const union {  uint32_t  u;  float32_t f; }
                 xmin={0x20000000}, // sqrt(realmin)
                 xmax={0x5f000000}, // sqrt(realmax)/2
                 k   ={0x6a800000}, // direct and inverse scale factors 
                 kinv={0x14800000}; //
    NASSERT( x );
    NASSERT( y );

    if ( N<2 || 0 != (N&(N-1)) || ( mode != 0 && mode != 1 ) ) return;
    change1632=AE_L16X4_I((const ae_int16x4*)change1632_tbl,0);

    logN = 30 - NSA( N );
    scale = XT_AE_MOVXTFLOATX2_FROMINT32X2(AE_MOVDA32((127+mode-logN)<<23));   /* 2^(mode-logN) */
    N=( mode ? N/2+1 : N );

    aY=AE_ZALIGN128();
    aX=AE_LA128_PP(x);
    nbytesRd=N<<3;
    nbytesWr=N<<2;
    for ( n=0; n<((N+3)>>2); n++)
    {
        xtbool2 bsmall,bbig;
        xtfloatx2 reim0,reim1,rere,imim,maxreim,r0,r1,t0,t1;
        xtfloatx2 s,sinv0,sinv1;
        AE_LAV16X4X2_XP(tmp0, tmp1,aX,castxcc(ae_int16x8,x), nbytesRd);  nbytesRd-=sizeof(ae_int16x8);
        AE_DSEL16X4(tmp0,tmp1,tmp1,tmp0,change1632);
        reim0=AE_MOVXTFLOATX2_FROMINT32X2(AE_MOVINT32X2_FROMINT16X4(tmp0));
        reim1=AE_MOVXTFLOATX2_FROMINT32X2(AE_MOVINT32X2_FROMINT16X4(tmp1));

        ABS_SX2X2(reim0,reim1,reim0,reim1);
        rere=AE_SEL32_HH_SX2(reim0,reim1);
        imim=AE_SEL32_LL_SX2(reim0,reim1);
        maxreim=MAXNUM_SX2(rere,imim);
        bsmall=XT_OLE_SX2(maxreim,xmin.f);
        bbig  =XT_OLE_SX2(xmax.f,maxreim);
        CONST_SX2X2(sinv0,s,1);
        XT_MOVT_SX2(s,k.f,bsmall);
        XT_MOVT_SX2(sinv0,kinv.f,bsmall);
        XT_MOVT_SX2(s,kinv.f,bbig);
        XT_MOVT_SX2(sinv0,k.f,bbig);
        sinv0=XT_MUL_SX2(sinv0,scale);
        MUL_SX2X2(rere,imim,rere,imim,s,s);
        MUL_SX2X2(r0,t0,rere,imim,rere,imim);

        AE_LAV16X4X2_XP(tmp0, tmp1,aX,castxcc(ae_int16x8,x), nbytesRd);  nbytesRd-=sizeof(ae_int16x8);
        AE_DSEL16X4(tmp0,tmp1,tmp1,tmp0,change1632);
        reim0=AE_MOVXTFLOATX2_FROMINT32X2(AE_MOVINT32X2_FROMINT16X4(tmp0));
        reim1=AE_MOVXTFLOATX2_FROMINT32X2(AE_MOVINT32X2_FROMINT16X4(tmp1));
        ABS_SX2X2(reim0,reim1,reim0,reim1);
        rere=AE_SEL32_HH_SX2(reim0,reim1);
        imim=AE_SEL32_LL_SX2(reim0,reim1);
        maxreim=MAXNUM_SX2(rere,imim);
        bsmall=XT_OLE_SX2(maxreim,xmin.f);
        bbig  =XT_OLE_SX2(xmax.f,maxreim);
        CONST_SX2X2(sinv1,s,1); 
        XT_MOVT_SX2(s,k.f,bsmall);
        XT_MOVT_SX2(sinv1,kinv.f,bsmall);
        XT_MOVT_SX2(s,kinv.f,bbig);
        XT_MOVT_SX2(sinv1,k.f,bbig);
        sinv1=XT_MUL_SX2(sinv1,scale);
        MUL_SX2X2(rere,imim,rere,imim,s,s);
        MUL_SX2X2(r1,t1,rere,imim,rere,imim);

        ADD_SX2X2(r0,r1,r0,r1,t0,t1);
        SQRT_SX2X2(r0,r1,r0,r1);
        MUL_SX2X2(r0,r1,r0,r1,sinv0,sinv1);


        tmp0=AE_MOVINT16X4_FROMINT32X2(AE_MOVINT32X2_FROMXTFLOATX2(r0));
        tmp1=AE_MOVINT16X4_FROMINT32X2(AE_MOVINT32X2_FROMXTFLOATX2(r1));
        AE_DSEL16X4(tmp0,tmp1,tmp1,tmp0,change1632);
        AE_SAV16X4X2_XP(tmp0,tmp1,aY,castxcc(ae_int16x8,y),nbytesWr); nbytesWr-=sizeof(ae_int16x8);
    }
    AE_SA128POS_FP(aY,castxcc(ae_int16x8,y));
} 
#else
{
    int n, logN;
    xtfloatx2 scale;
    ae_valign aY;
    ae_valignx2 aX;
    static const union {  uint32_t  u;  float32_t f; }
                 xmin={0x20000000}, // sqrt(realmin)
                 xmax={0x5f000000}, // sqrt(realmax)/2
                 k   ={0x6a800000}, // direct and inverse scale factors 
                 kinv={0x14800000}; //
    NASSERT( x );
    NASSERT( y );

    if ( N<2 || 0 != (N&(N-1)) || ( mode != 0 && mode != 1 ) ) return;

    logN = 30 - NSA( N );
    scale = XT_AE_MOVXTFLOATX2_FROMINT32X2(AE_MOVDA32((127+mode-logN)<<23));   /* 2^(mode-logN) */
    N=( mode ? N/2+1 : N );

    aY=AE_ZALIGN64();
    aX=AE_LA128_PP(x);
    for ( n=0; n<(N>>2); n++)
    {
        xtbool2 bsmall,bbig;
        xtfloatx2 reim0,reim1,rere,imim,maxreim,r0,r1,t0,t1;
        xtfloatx2 s,sinv0,sinv1;
        AE_LASX2X2_IP(reim0,reim1,aX,castxcc(xtfloatx4,x));
        ABS_SX2X2(reim0,reim1,reim0,reim1);
        rere=AE_SEL32_HH_SX2(reim0,reim1);
        imim=AE_SEL32_LL_SX2(reim0,reim1);
        maxreim=MAXNUM_SX2(rere,imim);
        bsmall=XT_OLE_SX2(maxreim,xmin.f);
        bbig  =XT_OLE_SX2(xmax.f,maxreim);
        CONST_SX2X2(sinv0,s,1);
        XT_MOVT_SX2(s,k.f,bsmall);
        XT_MOVT_SX2(sinv0,kinv.f,bsmall);
        XT_MOVT_SX2(s,kinv.f,bbig);
        XT_MOVT_SX2(sinv0,k.f,bbig);
        sinv0=XT_MUL_SX2(sinv0,scale);
        MUL_SX2X2(rere,imim,rere,imim,s,s);
        MUL_SX2X2(r0,t0,rere,imim,rere,imim);

        AE_LASX2X2_IP(reim0,reim1,aX,castxcc(xtfloatx4,x));
        ABS_SX2X2(reim0,reim1,reim0,reim1);
        rere=AE_SEL32_HH_SX2(reim0,reim1);
        imim=AE_SEL32_LL_SX2(reim0,reim1);
        maxreim=MAXNUM_SX2(rere,imim);
        bsmall=XT_OLE_SX2(maxreim,xmin.f);
        bbig  =XT_OLE_SX2(xmax.f,maxreim);
        CONST_SX2X2(sinv1,s,1); 
        XT_MOVT_SX2(s,k.f,bsmall);
        XT_MOVT_SX2(sinv1,kinv.f,bsmall);
        XT_MOVT_SX2(s,kinv.f,bbig);
        XT_MOVT_SX2(sinv1,k.f,bbig);
        sinv1=XT_MUL_SX2(sinv1,scale);
        MUL_SX2X2(rere,imim,rere,imim,s,s);
        MUL_SX2X2(r1,t1,rere,imim,rere,imim);

        ADD_SX2X2(r0,r1,r0,r1,t0,t1);
        SQRT_SX2X2(r0,r1,r0,r1);
        MUL_SX2X2(r0,r1,r0,r1,sinv0,sinv1);

        XT_SASX2IP(r0,aY,castxcc(xtfloatx2,y));
        XT_SASX2IP(r1,aY,castxcc(xtfloatx2,y));
    }
    AE_SA64POS_FP(aY,castxcc(xtfloatx2,y));
    // tail
    __Pragma("loop_count max=3")
    for ( n=0; n<(N&3); n++ )
    {
        xtbool2 bsmall,bbig;
        xtfloatx2 reim;
        xtfloat r, maxreim;
        xtfloatx2 s,sinv;
        XT_LSX2IP(reim,castxcc(xtfloatx2,x),sizeof(xtfloatx2));
        reim=XT_ABS_SX2(reim);
        maxreim=RMAXNUM_S(reim);
        bsmall=XT_OLE_SX2(maxreim,xmin.f);
        bbig  =XT_OLE_SX2(xmax.f,maxreim);
        sinv=s=XT_CONST_S(1); 
        XT_MOVT_SX2(s,k.f,bsmall);
        XT_MOVT_SX2(sinv,kinv.f,bsmall);
        XT_MOVT_SX2(s,kinv.f,bbig);
        XT_MOVT_SX2(sinv,k.f,bbig);
        sinv=XT_MUL_S(sinv,scale);
        reim=XT_MUL_SX2(reim,s);
        reim=XT_MUL_SX2(reim,reim);
        r=XT_RADD_SX2(reim);
        r=XT_SQRT_S(r);
        r=XT_MUL_S(r,sinv);
        XT_SSIP(r,castxcc(xtfloat,y),sizeof(float32_t));
    }
} 
#endif
#else
/* version for scalar FPU */
void fft_spectrumf     ( float32_t* y, const complex_float   * x, int N,                     int mode )
{
#define MAX_SCR_SZ ((MAX_ALLOCA_SZ/sizeof(float32_t))&~1)
    float32_t ALIGN(32) scr[MAX_SCR_SZ];
          xtfloat* restrict pScrWr;
    const xtfloat* restrict pScrRd;
    const xtfloat *restrict X;
          xtfloat *restrict Z;
    xtfloat knorm; 
    int n, logN,M;
    NASSERT( x );
    NASSERT( y );

  if ( N<2 || 0 != (N&(N-1)) || ( mode != 0 && mode != 1 ) ) return;

    logN = 30 - NSA( N );
    knorm = XT_WFR((127+mode-logN)<<23);    /* 2^(mode-logN) */
    N=( mode ? N/2+1 : N );

    while(N>0)
    {
        M=XT_MIN(N,MAX_SCR_SZ);
        /* first phase: normalize inputs to avoid under/overflows */
        __Pragma("no_reorder")
        X = (const xtfloat *)x;
        Z = (xtfloat *)y;
        pScrWr=(xtfloat*)scr;
        for ( n=0; n<(M); n++)
        {
            xtfloat Xre, Xim, temp;
            int32_t temp0, exp_re, exp_im, exp_abs;
            int32_t b_cond;
            XT_LSIP(Xre, X, sizeof(float32_t));
            XT_LSIP(Xim, X, sizeof(float32_t));
            /* Get the exponent of x.re */
            temp0 = XT_RFR(Xre);
            exp_re = ((uint32_t)temp0)>>23;
            exp_re = (exp_re & 0xFF);
            exp_re = (exp_re - 127);
            /*--------------------------*/
            /* Get the exponent of x.im */
            temp0 = XT_RFR(Xim);
            exp_im = ((uint32_t)temp0)>>23;
            exp_im = (exp_im & 0xFF);
            exp_im = (exp_im - 127);
            /*--------------------------*/
            /* Select maximum exponent */
            exp_abs = XT_MAX(exp_re, exp_im);
            XT_MOVLTZ(exp_abs,127,127-exp_abs);
            /* Adjust range of input data using ldexpf */
            /* Xre = ldexpf(Xre, -exp_abs) */
            /* Xim = ldexpf(Xim, -exp_abs) */
            temp0 = (127- exp_abs);
            b_cond = temp0;
            temp0 = (temp0<<23);
            XT_MOVEQZ(temp0,0x00400000, b_cond);
            temp = XT_WFR(temp0);
            Xre = XT_MUL_S(Xre, temp);
            Xim = XT_MUL_S(Xim, temp);
            /*-----------------------------*/
            /* Zout = sqrt(Xre*Xre + Xim*Xim) */
            temp = XT_MUL_S(Xre, Xre);
            XT_MADD_S(temp, Xim, Xim);
            ((int32_t*)Z)[0]=exp_abs; Z++;
            XT_SSIP(temp,pScrWr,sizeof(float32_t));
        }
        /* compute square root and renormalize output */
        __Pragma("no_reorder")
        X = (xtfloat *)y;
        Z = (xtfloat *)y;
        pScrRd=(xtfloat*)scr;
        for ( n=0; n<(M); n++)
        {
            int32_t exp_abs,temp0;
            xtfloat temp,Zout;
            int32_t b_cond;
            exp_abs = ((const int32_t*)X)[0];X++;
            XT_LSIP(temp,pScrRd,sizeof(float32_t));
            Zout = XT_SQRT_S(temp);
 
            /* Restore range of result      */
            /* Zout = ldexpf(Zout, exp_abs) */
           temp0 = (127+exp_abs);
           b_cond = temp0;
           temp0 = (temp0<<23);
           XT_MOVEQZ(temp0,0x00400000, b_cond);
           temp = XT_WFR(temp0);
           Zout = XT_MUL_S(Zout, temp);
           Zout = XT_MUL_S(Zout, knorm);
            /*------------------------------*/
            XT_SSIP(Zout, Z, sizeof(float32_t));
        }

        N-=M;
        y+=M;
        x+=M;
    }
}
#endif
